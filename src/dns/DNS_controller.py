import random
from random import randrange
from scapy.all import *
from scapy.layers.dns import IP, UDP, DNS, DNSQR, DNSRR


from dns import dns_settings
from dns.blacklists.blacklist_parser import get_adservers_list, get_ad_blocker_response


class Packet:
    class IP:
        def __init__(self, src, dst):
            self.src = src
            self.dst = dst
            
    class UDP:
        def __init__(self, sport, dport):
            self.sport = sport
            self.dport = dport
    
    class DNSRR:
        def __init__(self, rrname = '', type = '', rdata = ''):
            self.rrname = rrname
            self.type = type
            self.rdata = rdata
    
    class DNSQR:
        def __init__(self, qname, qtype):
            self.qname = qname                      # query name
            self.qtype = qtype                      # query type   1 = A, 2 = NS, 5 = CNAME, 15 = MX, 28 = AAAA
            self.qclass = 1                         # query class  1 = IN (Internet)
            
    class DNS:
        def __init__(self, id, qr, rcode, rd, aa = 0, qd=None, an=None, ns=None, ar=None):
            self.id = id                            # request ID
            self.qr = qr                            # query response    0 = query, 1 = response
            self.aa = aa                            # authoritative answer
            self.rcode = rcode                      # response code     0 = no error 
            self.rd = rd                            # recursion desired
            self.qd = qd if qd else Packet.DNSQR()  # query domain
            self.an = an if an else Packet.DNSRR()  # answer domain
            self.an = ns if ns else Packet.DNSRR()  # authoritative domain
            self.opcode = 0                         # operation code    0 = standard query

class DNSController:
    adservers = get_adservers_list(dns_settings.ADSERVERS_LOCATION) 
    facebook = get_adservers_list(dns_settings.FACEBOOK_LOCATION)
    
    @staticmethod
    def google_request(DNS_packet, timeout = 20):
        return sr1(IP(dst = dns_settings.GOOGLE_DNS_IP) / UDP(dport = dns_settings.UDP_PORT) / DNS_packet, verbose = 0, timeout = timeout)

    @staticmethod
    def send_response_server_error(DNS_packet):
        """Sent when an error occurs"""
        DNS_error_response = DNS(
            id = DNS_packet[DNS].id,
            qr = 1,
            aa = 0,
            rcode = 2,
            qd = DNS_packet.qd
        )
        
        return DNS_error_response

    @staticmethod
    def pick_random_root_server():
        return random.choice(dns_settings.ROOT_SERVERS_IP)

    @staticmethod
    def send_request_root_server(DNS_packet):
        """
        Sends a DNS request packet to a randomly chosen root server.    
        If successful, returns a response from the root server or a response from a TLD server if necessary.
        If unsuccessful, returns a server error response.
        """
        root_server_ip = DNSController.pick_random_root_server()
        root_ip = IP(dst = root_server_ip)
        # root servers do not offer recursivity
        DNS_packet.rd = 0
        
        root_response = sr1(root_ip / UDP(dport = dns_settings.UDP_PORT) / DNS_packet, verbose = 0, timeout = 2)

        if not root_response:
            return DNSController.send_response_server_error(DNS_packet)

        if root_response[DNS].rcode != 0:
            return root_response

        # Ensure there are at least 2 additional responses, as there might be only one, 
        # possibly of type OPT, which contains additional information
        if root_response.arcount > 1:
            ar_cnt = randrange(root_response.arcount)

            while root_response.ar[ar_cnt].type != 1:
                ar_cnt = randrange(root_response.arcount)

            response = root_response.ar[ar_cnt]

        else:
            # If there are no additional answers, we need to search for the 
            # name of an NS (authority section) that knows how to handle this request.
            ns_cnt = randrange(root_response.nscount)
            response = root_response.ns[ns_cnt]

            # ask google to get the address of the desired NS record 
            DNSRR_auth_query = DNSQR(qname = response.rdata, qtype = 1, qclass = 1)
            DNS_packet = DNS(qd = DNSRR_auth_query, rd = 1)
            DNSRR_auth_IP = DNSController.google_request(DNS_packet, timeout = 2)
            response = DNSRR_auth_IP[DNS].an

        return DNSController.send_request_tld_server(DNS_packet, response.rdata)        

    @staticmethod
    def send_request_tld_server(DNS_packet, TLD_ip):
        """
        Sends a DNS request packet to the Top-Level Domain (TLD) server.
        If successful, returns a response from the TLD server or a response from an authoritative server if necessary.
        If unsuccessful, returns a server error response.
        """
        TLD_response = sr1(IP(dst=TLD_ip) / UDP(dport=dns_settings.UDP_PORT) / DNS_packet, verbose=0, timeout=2)

        if TLD_response:
            if TLD_response[DNS].rcode != 0:
                return TLD_response

            # Check if the TLD returns the desired record(s)
            if TLD_response.ancount > 0:
                return TLD_response

            elif TLD_response.arcount > 1:
                ar_cnt = randrange(TLD_response.arcount)

                while TLD_response.ar[ar_cnt].type != 1:
                    ar_cnt = randrange(TLD_response.arcount)

                response = TLD_response.ar[ar_cnt]
            else:
                # If there are no additional answers, search for the name of an NS (authority section) that knows how to handle this request
                ns_cnt = randrange(TLD_response.nscount)
                DNSRR_auth = TLD_response.ns[ns_cnt]

                # If we receive a record of type SOA, it means that the request was not fulfilled, so we need to return this response
                if DNSRR_auth.type == 6:
                    return TLD_response

                # A request to the Google server which will return the desired NS
                DNSRR_auth_query = DNSQR(qname = DNSRR_auth.rdata, qtype = 1, qclass = 1)
                DNS_packet = DNS(qd = DNSRR_auth_query, rd = 1)
                DNSRR_auth_IP = DNSController.google_request(DNS_packet, timeout = 2)

                if not DNSRR_auth_IP:
                    return DNSRR_auth_IP

                response = DNSRR_auth_IP[DNS].an

            # Forward the request to the authoritative server
            return DNSController.send_request_authoritative_server(DNS_packet, response.rdata)
        else:
            # If the TLD server does not return a response, send a response indicating that the request could not be resolved by the server
            return DNSController.send_response_server_error(DNS_packet)

    @staticmethod
    def send_request_authoritative_server(DNS_packet, authoritative_ip):
        """
        Sends a DNS request packet to the authoritative server.
        If successful, returns a response from the authoritative server.
        If unsuccessful, returns None.
        """
        authoritative_response = sr1(IP(dst=authoritative_ip) / UDP(dport=dns_settings.UDP_PORT) / DNS_packet, verbose=0, timeout=2)

        if not authoritative_response:
            return None
    
        # Need to search in one of the received NS for the queried domain unless a NS request and no answers exist
        if DNS_packet.qd.qtype != 2 and authoritative_response.nscount > 0 and authoritative_response.an is None:
            # While the authority returns NS and not A, we ask Google for the address of the NS and then ask further at the NS address
            while authoritative_response and authoritative_response.nscount > 0 and authoritative_response.ns.type == 2 and authoritative_response.an is None:
    
                DNSRR_auth_query = DNSQR(qname = authoritative_response.ns.rdata, qtype = 1, qclass = 1)
                DNS_packet = DNS(qd = DNSRR_auth_query, rd = 1)
                authoritative_response = DNSController.google_request(DNS_packet, timeout = 2)
                # To find the IP of the domain, send a request to the NS server we found in the previous step
                authoritative_response = sr1(IP(dst=authoritative_response.an.rdata) / UDP(dport=dns_settings.UDP_PORT) / DNS_packet[DNS], verbose=0, timeout=2)
                
        # If the request is of type A / AAAA and the received record is CNAME then 
        # send a request to our server to return the IP address for that CNAME
        if (DNS_packet.qd.qtype == 1 or DNS_packet.qd.qtype == 28) and authoritative_response.an and authoritative_response.an.type == 5:
            DNS_req = DNS()
            DNS_req_qd = DNSQR(qname=authoritative_response.an.rdata, qtype=DNS_packet.qd.qtype, qclass=1)
            DNS_req.qd = DNS_req_qd

            return DNSController.send_request_root_server(DNS_req)
        
        return authoritative_response

    @staticmethod
    def filter_dns_answer(response, DNS_packet):
        DNS_response = response[DNS]
        DNS_response.id = DNS_packet[DNS].id    # answer's ID needs to be the same as the initial request from our server
        DNS_response.aa = 0                     # can't say we are authoritative answer
        DNS_response.qd = DNS_packet.qd         # answer's query needs to be the same as the initial request from our server
        return DNS_response

    @staticmethod
    def single_record_lookup(DNS_packet):
        domain_requested = DNS_packet.qd.qname.decode()[:-1]

        if domain_requested in DNSController.adservers or domain_requested in DNSController.facebook:
            return get_ad_blocker_response(DNS_packet)

        response = DNSController.send_request_root_server(DNS_packet)

        return DNSController.filter_dns_answer(response, DNS_packet) if response else DNSController.send_response_server_error(DNS_packet)

    @staticmethod
    def multiple_records_lookup(DNS_packet):
        domain_requested = DNS_packet.qd.qname.decode()[:-1]

        if domain_requested in DNSController.adservers or domain_requested in DNSController.facebook:
            return get_ad_blocker_response(DNS_packet)
        
        response = DNSController.send_request_root_server(DNS_packet)

        if not response:
            return DNSController.send_response_server_error(DNS_packet)

        DNS_response = DNSController.filter_dns_answer(response, DNS_packet)

        if DNS_response.rcode == 0 and DNS_response.ancount > 0:
            for answer in range(DNS_response.ancount):
                NS_domain = DNS_response.an[answer].rdata.decode()[:-1] if DNS_packet.qd.qtype == 2 else DNS_response.an[answer].exchange.decode()[:-1]

                if NS_domain in DNSController.adservers or NS_domain in DNSController.facebook:
                    return get_ad_blocker_response(DNS_packet)

        return DNS_response
    
    @staticmethod
    def interpret_DNS_qtype(type):
        match type:
            case 1:
                return "A"
            case 2:
                return "NS"
            case 5:
                return "CNAME"
            case 15:
                return "MX"
            case 28:
                return "AAAA"
            case _:
                return "UNKNOWN"

    @staticmethod
    def display_DNS_query(DNS_packet):
        domain_requested = DNS_packet.qd.qname.decode()[:-1]
        record_type = DNSController.interpret_DNS_qtype(DNS_packet.qd.qtype)

        print("=========================")
        print("DNS request")
        print("=========================")
        print(f"| Request ID: {DNS_packet.id}")
        print(f"| Domain: {domain_requested}")
        print(f"| Record type: {record_type}")
        print("=========================")
        print()

    @staticmethod
    def display_DNS_response(DNS_packet):
        print("=========================")
        print("DNS response")
        print("=========================")
        print(f"| Request ID: {DNS_packet.id}")
        print(f"| QR: {DNS_packet.qr}")
        print(f"| Operation code: {DNS_packet.opcode}")
        print(f"| Response code: {DNS_packet.rcode}")
        print(f"| QDcount: {DNS_packet.qdcount}")
        print(f"| ANcount: {DNS_packet.ancount}")
        print(f"| NScount: {DNS_packet.nscount}")
        print(f"| ARcount: {DNS_packet.arcount}")
            
        print("-------------------------")
        print("|| Questions: ")
        print("-------------------------")
        if DNS_packet.qd:
            DNS_packet.qd.show()

        print("-------------------------")
        print("|| Answers: ")
        print("-------------------------")
        if DNS_packet.an:
            DNS_packet.an.show()

        print("-------------------------")
        print("|| Authority: ")
        print("-------------------------")
        if DNS_packet.ns:
            DNS_packet.ns.show()

        print("-------------------------")
        print("|| Additional: ")
        print("-------------------------")
        if DNS_packet.ar:
            DNS_packet.ar.show()
        
        print("=========================")
        print()
