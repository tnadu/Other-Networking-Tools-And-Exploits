from socket import gethostbyname
from scapy.all import *
import requests
import logging
import argparse


class Host:     # pragma: no mutate
    def __init__(self, ip_address: str = None, hostname: str = None, country: str = None, region: str = None, city: str = None):    # pragma: no mutate
        self.ip_address = ip_address    # pragma: no mutate
        self.hostname = hostname        # pragma: no mutate
        self.country = country          # pragma: no mutate
        self.region = region            # pragma: no mutate
        self.city = city                # pragma: no mutate

    @classmethod
    def from_dict(cls, dictionary):     # pragma: no mutate
        return cls(dictionary.get("ip"), dictionary.get("hostname"), dictionary.get("country"), dictionary.get("region"), dictionary.get("city"))   # pragma: no mutate

    def __eq__(self, other):    # pragma: no cover
        if not isinstance(other, type(self)):   # pragma: no mutate
            return False    # pragma: no mutate

        if self.ip_address != other.ip_address:     # pragma: no mutate
            return False    # pragma: no mutate

        if self.hostname != other.hostname:     # pragma: no mutate
            return False    # pragma: no mutate

        if self.country != other.country:   # pragma: no mutate
            return False    # pragma: no mutate

        if self.region != other.region:     # pragma: no mutate
            return False    # pragma: no mutate

        if self.city != other.city:     # pragma: no mutate
            return False    # pragma: no mutate

        return True     # pragma: no mutate


def validate_api_token(api_token):
    # using an invalid API token will result in an error being returned within the response;
    # the ip which is queried has no significance, hence 1.1.1.1 is a suitable default
    response = requests.get(f"https://ipinfo.io/1.1.1.1?token={api_token}")
    if response.status_code != 200:
        raise ValueError("Invalid API token!")


class Traceroute:
    def __init__(self, api_token: str, logger: logging.Logger):
        self.__api_token = api_token
        self.__logger = logger
        validate_api_token(api_token)

    def _create_host_instance(self, ip_address: str) -> Host:
        ip_info = requests.get(f"https://ipinfo.io/{ip_address}?token={self.__api_token}").json()
        return Host(ip_info.get("ip"), ip_info.get("hostname"), ip_info.get("country"), ip_info.get("region"), ip_info.get("city"))

    def __log_host_on_current_route(self, id: int, host: Host) -> None:     # pragma: no mutate
        self.__logger.info(                     # pragma: no mutate
            f"{id}. {host.ip_address} -> "      # pragma: no mutate
            f"hostname: {host.hostname}, "      # pragma: no mutate
            f"country: {host.country}, "        # pragma: no mutate
            f"region: {host.region}, "          # pragma: no mutate
            f"city: {host.city}"                # pragma: no mutate
        )

    def fetch_route(self, host: str, maximum_number_of_hops: int = 64, timeout: int = 5, udp_port: int = 33436) -> list[Host]:
        target_ip_address = gethostbyname(host)
        self.__logger.debug(f"Resolved '{host}' to '{target_ip_address}'.")     # pragma: no mutate
        self.__logger.info(f"Searching for '{target_ip_address}'")      # pragma: no mutate

        route = []
        for ttl in range(1, maximum_number_of_hops + 1):
            packet = IP(dst=target_ip_address, ttl=ttl) / UDP(dport=udp_port)
            response = sr1(packet, verbose=False, timeout=timeout)

            # (probably) overloaded router chose not to
            # send an ICMP response back to the host
            if response is None:
                route.append(Host())
                self.__logger.info(f"{ttl}. * * *")     # pragma: no mutate
                continue

            next_host_on_current_route = self._create_host_instance(response.src)
            route.append(next_host_on_current_route)
            self.__log_host_on_current_route(ttl, next_host_on_current_route)       # pragma: no mutate

            # destination unreachable, generated by the use of a reserved
            # port in the UDP request; this means that the packet reached
            # the intended destination successfully
            if response.type == 3:
                break
        else:
            self.__logger.info("Could not reach destination!")  # pragma: no mutate

        return route


def main(arguments, logger):    # pragma: no cover
    try:    # pragma: no mutate
        traceroute = Traceroute(arguments.api_token, logger)    # pragma: no mutate
        traceroute.fetch_route(arguments.destination, arguments.maximum_number_of_hops, arguments.timeout, arguments.reserved_port)     # pragma: no mutate
    except KeyboardInterrupt:   # pragma: no mutate
        logger.info("Quiting...")   # pragma: no mutate


if __name__ == "__main__":      # pragma: no mutate
    logging.basicConfig(level=logging.INFO, format="[*] %(message)s")   # pragma: no mutate
    logger = logging.getLogger()    # pragma: no mutate

    parser = argparse.ArgumentParser(   # pragma: no mutate
        description="Traceroute implementation using UDP packets generated with scapy, and ipinfo.io for IP address information.",      # pragma: no mutate
        epilog="When no response is received from a router, the characteristic '* * *' string is shown."    # pragma: no mutate
    )   # pragma: no mutate

    parser.add_argument("-d", "--destination", required=True, type=str,     # pragma: no mutate
                        help="destination host; both IP addresses and hostnames are allowed")   # pragma: no mutate
    parser.add_argument("-a", "--api-token", required=True, type=str, dest="api_token", help="ipinfo.io API token",     # pragma: no mutate
                        metavar="API-TOKEN")    # pragma: no mutate
    parser.add_argument("-m", "--max-hops", default=64, type=int, dest="maximum_number_of_hops",    # pragma: no mutate
                        help="the maximum number of hosts to the destination; defaults to 64", metavar="MAX-HOPS")  # pragma: no mutate
    parser.add_argument("-t", "--timeout", default=5, type=int,     # pragma: no mutate
                        help="amount of time to wait for a response from a server; defaults to 5s")     # pragma: no mutate
    parser.add_argument("-p", "--reserved-port", default=33436, type=int, dest="reserved_port",     # pragma: no mutate
                        help="a reserved UDP port of the target, to which the empty packet is sent", metavar="RESERVED-PORT")   # pragma: no mutate

    arguments = parser.parse_args()     # pragma: no mutate
    main(arguments, logger)     # pragma: no mutate
