from socket import gethostbyname
from scapy.all import *
import requests
import logging
import argparse


class Host:
    def __init__(self, ip_address: str = None, hostname: str = None, country: str = None, region: str = None, city: str = None):
        self.ip_address = ip_address
        self.hostname = hostname
        self.country = country
        self.region = region
        self.city = city


class Traceroute:
    def __init__(self, api_token: str, logger: logging.Logger):
        self.__api_token = api_token
        self.__logger = logger

    def __create_host_instance(self, ip_address: str) -> Host:
        ip_info = requests.get(f"https://ipinfo.io/{ip_address}?token={self.__api_token}").json()
        return Host(ip_info.get("ip"), ip_info.get("hostname"), ip_info.get("country"), ip_info.get("region"), ip_info.get("city"))


def printRouteData(id, ip, apiToken):
    # using the provided token associated with an ipinfo account, a get request is issued to their API
    response = requests.get(f'https://ipinfo.io/{ip}?token={apiToken}')
    jsonedResponse = response.json()

    if 'bogon' in jsonedResponse:
        print(f"{id}. {jsonedResponse['ip']} -> bogon")
    else:
        print(
            f'{id}. {jsonedResponse["ip"]} -> '
            f'hostname: {jsonedResponse.get("hostname", "unknown")}, '
            f'country: {jsonedResponse.get("country", "unknown")}, '
            f'region: {jsonedResponse.get("region", "unknown")}, '
            f'city: {jsonedResponse.get("city", "unknown")}')


def traceroute(ip, apiToken, maximumNumberOfHops, timeout):
    print(f"[*] searching for {ip}...")

    for ttl in range(1, maximumNumberOfHops):
        # create the UDP packet
        packet = IP(dst=ip, ttl=ttl) / UDP(dport=33436)
        # send the packet and receive the response
        reply = sr1(packet, verbose=False, timeout=timeout)

        # (probably) overloaded router chose not to
        # send an ICMP response back to the host
        if reply is None:
            print(f'{ttl}. * * *')
        else:
            # destination unreachable, generated by the use of a reserved
            # port in the UDP request; this means that the packet reached
            # the intended destination successfully
            if reply.type == 3:
                print("[*] Destination reached!")
                break

            printRouteData(ttl, reply.src, apiToken)


parser = argparse.ArgumentParser(
    description='Traceroute implementation using UDP packets generated with scapy and ipinfo.io for IP address information.',
    epilog='When no response is received from a router, the characteristic "* * *" string is shown.'
)

parser.add_argument('-d', '--destination', required=True, type=str,
                    help='destination host; both IP addresses and hostnames are allowed')
parser.add_argument('-a', '--api-token', required=True, type=str, dest='apiToken', help='ipinfo.io API token',
                    metavar='API-TOKEN')
parser.add_argument('-m', '--max-hops', default=30, type=int, dest='maximumNumberOfHops',
                    help='the allowed number of hops to the destination; defaults to 30', metavar='MAX-HOPS')
parser.add_argument('-t', '--timeout', default=5, type=int,
                    help='amount of time to wait for a response from a server; defaults to 5s')

arguments = parser.parse_args()

try:
    traceroute(gethostbyname(arguments.destination), arguments.apiToken, arguments.maximumNumberOfHops + 1, arguments.timeout)
except KeyboardInterrupt:
    print('[*] Goodbye!')
