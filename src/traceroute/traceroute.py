from socket import gethostbyname
from scapy.all import *
import requests
import logging
import argparse


class Host:
    def __init__(self, ip_address: str = None, hostname: str = None, country: str = None, region: str = None, city: str = None):
        self.ip_address = ip_address
        self.hostname = hostname
        self.country = country
        self.region = region
        self.city = city


class Traceroute:
    def __init__(self, api_token: str, logger: logging.Logger):
        self.__api_token = api_token
        self.__logger = logger

    def __create_host_instance(self, ip_address: str) -> Host:
        ip_info = requests.get(f"https://ipinfo.io/{ip_address}?token={self.__api_token}").json()
        return Host(ip_info.get("ip"), ip_info.get("hostname"), ip_info.get("country"), ip_info.get("region"), ip_info.get("city"))

    def __log_host_on_current_route(self, id: int, host: Host) -> None:
        self.__logger.info(
            f"{id}. {host.ip_address} -> "
            f"hostname: {host.hostname}, "
            f"country: {host.country}, "
            f"region: {host.region}, "
            f"city: {host.city}"
        )

    def fetch_route(self, host: str, maximum_number_of_hops: int = 64, timeout: int = 5, udp_port: int = 33436) -> list[Host]:
        target_ip_address = gethostbyname(host)
        self.__logger.debug(f"Resolved '{host}' to '{target_ip_address}'.")
        self.__logger.info(f"Searching for '{target_ip_address}'")

        route = []
        for ttl in range(1, maximum_number_of_hops + 1):
            packet = IP(dst=target_ip_address, ttl=ttl) / UDP(dport=udp_port)
            response = sr1(packet, verbose=False, timeout=timeout)

            # (probably) overloaded router chose not to
            # send an ICMP response back to the host
            if response is None:
                route.append(Host())
                self.__logger.info(f"{ttl}. * * *")
                continue

            next_host_on_current_route = self.__create_host_instance(response.src)
            route.append(next_host_on_current_route)
            self.__log_host_on_current_route(ttl, next_host_on_current_route)

            # destination unreachable, generated by the use of a reserved
            # port in the UDP request; this means that the packet reached
            # the intended destination successfully
            if response.type == 3:
                break
        else:
            self.__logger.info("Could not reach destination!")

        return route


def main(arguments, logger):
    try:
        traceroute = Traceroute(arguments.api_token, logger)
        traceroute.fetch_route(arguments.destination, arguments.maximum_number_of_hops, arguments.timeout, arguments.reserved_port)
    except KeyboardInterrupt:
        logger.info("Quiting...")


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, format="[*] %(message)s")
    logger = logging.getLogger()

    parser = argparse.ArgumentParser(
        description="Traceroute implementation using UDP packets generated with scapy, and ipinfo.io for IP address information.",
        epilog="When no response is received from a router, the characteristic '* * *' string is shown."
    )

    parser.add_argument("-d", "--destination", required=True, type=str,
                        help="destination host; both IP addresses and hostnames are allowed")
    parser.add_argument("-a", "--api-token", required=True, type=str, dest="api_token", help="ipinfo.io API token",
                        metavar="API-TOKEN")
    parser.add_argument("-m", "--max-hops", default=64, type=int, dest="maximum_number_of_hops",
                        help="the maximum number of hosts to the destination; defaults to 64", metavar="MAX-HOPS")
    parser.add_argument("-t", "--timeout", default=5, type=int,
                        help="amount of time to wait for a response from a server; defaults to 5s")
    parser.add_argument("-p", "--reserved-port", default=33436, type=int, dest="reserved_port",
                        help="a reserved UDP port of the target, to which the empty packet is sent", metavar="RESERVED-PORT")

    arguments = parser.parse_args()
    main(arguments, logger)
