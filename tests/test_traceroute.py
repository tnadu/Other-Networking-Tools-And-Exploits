import pytest
import re

from copy import deepcopy
from traceroute.traceroute import validate_api_token, Host, Traceroute


@pytest.fixture
def invalid_api_token():
    return "completely-invalid-api-token"


@pytest.fixture
def valid_api_token():
    return "completely-valid-api-token"


@pytest.fixture
def non_bogon_payload():
    return {"ip": "valid-ip-address", "hostname": "valid-hostname", "city": "valid-city", "region": "valid-region", "country": "valid-country"}


@pytest.fixture
def bogon_payload():
    return {"ip": "reserved-ip-address", "bogon": "true"}


@pytest.fixture
def destination_hosts():
    hostname_given = {
        "target": "wikipedia.org",
        "ip": "185.15.59.224",
        "hostname": "text-lb.esams.wikimedia.org",
        "country": "NL",
        "region": "North Holland",
        "city": "Amsterdam",
    }

    ip_given = {
        "target": "1.1.1.1",
        "ip": "1.1.1.1",
        "hostname": "one.one.one.one",
        "country": "AU",
        "region": "New South Wales",
        "city": "The Rocks",
    }

    return [hostname_given, ip_given]


@pytest.fixture
def hosts_found_on_route():
    hosts = [
        {
            "ip": "192.168.0.1",
            "hostname": "",
            "country": "",
            "region": "",
            "city": "",
        },
        {
            "ip": "10.0.0.2",
            "hostname": "",
            "country": "",
            "region": "",
            "city": "",
        },
        {
            "ip": "10.30.4.209",
            "hostname": "",
            "country": "",
            "region": "",
            "city": "",
        },
        {
            "ip": "10.220.185.232",
            "hostname": "",
            "country": "",
            "region": "",
            "city": "",
        },
        {
            "ip": "188.2.23.4",
            "hostname": "cable-188-2-23-4.dynamic.sbb.rs",
            "country": "RS",
            "region": "Vojvodina",
            "city": "Novi Sad",
        },
        {
            "ip": "72.14.216.212",
            "hostname": "",
            "country": "HU",
            "region": "Budapest",
            "city": "Budapest",
        },
        {
            "ip": "172.253.65.251",
            "hostname": "",
            "country": "HU",
            "region": "Budapest",
            "city": "Budapest",
        },
        {
            "ip": "154.239.28.85",
            "hostname": "",
            "region": "North Rhine-Westphalia",
            "country": "DE",
            "city": "DÃ¼sseldorf",
        },
        {
            "ip": "185.15.59.225",
            "hostname": "",
            "region": "North Holland",
            "country": "NL",
            "city": "Amsterdam",
        },
        {
            "ip": "52.95.120.34",
            "hostname": "",
            "region": "Leinster",
            "country": "IE",
            "city": "Dublin",
        },
        {
            "ip": "54.239.28.85",
            "hostname": "",
            "region": "Virginia",
            "country": "US",
            "city": "Ashburn",
        }
    ]

    return hosts


@pytest.fixture
def expected_and_mock_route_no_destination(mocker, hosts_found_on_route):
    # after each index in the original route, a number of empty hosts/responses are inserted
    number_of_empty_responses_at_index = {
        0: {"number_of_responses": 2},
        3: {"number_of_responses": 3},
        6: {"number_of_responses": 1},
        8: {"number_of_responses": 2},
        10: {"number_of_responses": 4}
    }

    expected_route = []
    mock_route = []

    for i, host in enumerate(hosts_found_on_route):
        expected_route.append(Host.from_dict(host))

        response = mocker.Mock()
        response.src = host["ip"]
        response.type = 11  # time exceeded
        mock_route.append(response)

        if i in number_of_empty_responses_at_index:
            empty_hosts = [Host() for _ in range(number_of_empty_responses_at_index[i]["number_of_responses"])]
            empty_responses = [None] * number_of_empty_responses_at_index[i]["number_of_responses"]

            expected_route.extend(empty_hosts)
            mock_route.extend(empty_responses)

    return expected_route, mock_route


@pytest.fixture
def expected_and_mock_route_with_hostname_given_destination(mocker, destination_hosts, expected_and_mock_route_no_destination):
    expected_route, mock_route = expected_and_mock_route_no_destination
    expected_route = deepcopy(expected_route)
    mock_route = deepcopy(mock_route)
    expected_route.append(Host.from_dict(destination_hosts[0]))

    response = mocker.Mock()
    response.src = destination_hosts[0]["ip"]
    response.type = 3
    mock_route.append(response)

    # adding extra empty responses for certain test cases
    expected_route.extend([Host() for _ in range(len(expected_route))])
    mock_route.extend([None] * len(mock_route))

    return expected_route, mock_route


@pytest.fixture
def expected_and_mock_route_with_ip_given_destination(mocker, destination_hosts, expected_and_mock_route_no_destination):
    expected_route, mock_route = expected_and_mock_route_no_destination
    expected_route = deepcopy(expected_route)
    mock_route = deepcopy(mock_route)
    expected_route.append(Host.from_dict(destination_hosts[1]))

    response = mocker.Mock()
    response.src = destination_hosts[1]["ip"]
    response.type = 3
    mock_route.append(response)

    # adding extra empty responses for certain test cases
    expected_route.extend([Host() for _ in range(len(expected_route))])
    mock_route.extend([None] * len(mock_route))

    return expected_route, mock_route


@pytest.fixture
def mock_requests_get(mocker, valid_api_token, invalid_api_token, non_bogon_payload, bogon_payload):
    failed_payload_due_to_ip_address = {"status": 404, "error": {"title": "Wrong ip", "message": "Please provide a valid IP address"}}
    failed_payload_due_to_api_token = {"status": 403, "error": {"title": "Unknown token",
        "message": "Please ensure you've entered your token correctly. Refer to https://ipinfo.io/developers for details, or contact us at support@ipinfo.io for help"}}

    successful_non_bogon_response = mocker.Mock()
    successful_non_bogon_response.status_code = 200
    successful_non_bogon_response.json.return_value = non_bogon_payload

    successful_bogon_response = mocker.Mock()
    successful_bogon_response.status_code = 200
    successful_bogon_response.json.return_value = bogon_payload

    failed_response_due_to_ip_address = mocker.Mock()
    failed_response_due_to_ip_address.status_code = 404
    failed_response_due_to_ip_address.json.return_value = failed_payload_due_to_ip_address

    failed_response_due_to_api_token = mocker.Mock()
    failed_response_due_to_api_token.status_code = 403
    failed_response_due_to_api_token.json.return_value = failed_payload_due_to_api_token

    failed_response_due_to_bad_request = mocker.Mock()
    failed_response_due_to_bad_request.status_code = 404
    failed_response_due_to_bad_request.json.return_value = {}

    def mock_get(url: str):
        if not url.startswith("https://ipinfo.io/"):
            return failed_response_due_to_bad_request

        # the ip address and the api token must be delimited by '?token='
        parameters = url.lstrip("https://ipinfo.io/").split("?token=")
        if not len(parameters) == 2:
            return failed_response_due_to_bad_request

        ip_address, api_token = parameters

        # check validity of ip address
        if re.fullmatch(r"((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])", ip_address) is None:
            return failed_response_due_to_ip_address

        if api_token not in [valid_api_token, ""]:
            return failed_response_due_to_api_token

        if re.match(r"(127\.|192\.168\.|10\.|172\.1[6-9]\.|172\.2[0-9]\.|172\.3[0-1]\.)", ip_address) is not None:
            return successful_bogon_response

        return successful_non_bogon_response

    return mock_get, successful_non_bogon_response, successful_bogon_response, failed_response_due_to_ip_address, failed_response_due_to_api_token, failed_response_due_to_bad_request


@pytest.fixture
def mock_gethostbyname(destination_hosts):
    ip_addresses = {host["target"]: host["ip"] for host in destination_hosts}

    def gethostbyname(hostname):
        ip_address = ip_addresses.get(hostname)

        if ip_address is None:
            raise OSError(-5, "No address associated with hostname")

        return ip_address

    return gethostbyname


@pytest.fixture
def mock_create_host_instance(hosts_found_on_route, destination_hosts):
    hosts = {host["ip"]: Host.from_dict(host) for host in hosts_found_on_route + destination_hosts}

    def create_host_instance(self, ip_address):
        return hosts.get(ip_address)

    return create_host_instance


def test_api_token_validity(mocker, valid_api_token, invalid_api_token, mock_requests_get):
    mock_get, _, _, _, _, _ = mock_requests_get
    mocker.patch("traceroute.traceroute.requests.get", mock_get)

    validate_api_token(valid_api_token)
    # the ipinfo API works even when no API token is provided
    validate_api_token("")

    with pytest.raises(ValueError) as exception_information:
        validate_api_token(invalid_api_token)
    assert str(exception_information.value) == "Invalid API token!"


def test_create_host_instance(mocker, valid_api_token, non_bogon_payload, bogon_payload, mock_requests_get):
    logger = mocker.Mock()
    mock_validate_api_token = mocker.Mock()
    mock_get, successful_non_bogon_response, successful_bogon_response, failed_response_due_to_ip_address, _, _ = mock_requests_get

    mocker.patch("traceroute.traceroute.validate_api_token", mock_validate_api_token)
    mocker.patch("traceroute.traceroute.requests.get", mock_get)

    non_bogon_ip_addresses = ["1.1.1.1", "34.35.46.1", "212.44.78.9"]
    bogon_ip_addresses = ["192.168.0.1", "172.20.0.1", "10.0.0.1"]
    invalid_ip_addresses = ["300.400.500.600", "192.168.0.256", "192.168.0", "192.168.0.1.2", "192.168.0.-1", "192.168.0.foo", "192,168,0,1", "192.168.0.01"]

    # the response returned by `mock_get` will be identical for every request in a certain category (non-bogon, bogon, invalid)
    filled_host = Host(non_bogon_payload["ip"], non_bogon_payload["hostname"], non_bogon_payload["country"], non_bogon_payload["region"], non_bogon_payload["city"])
    bogon_host = Host(bogon_payload["ip"])
    empty_host = Host()

    test_traceroute = Traceroute(valid_api_token, logger)
    mock_validate_api_token.assert_called_once()

    for ip_address in non_bogon_ip_addresses:
        successful_non_bogon_response.json.reset_mock()
        host = test_traceroute._create_host_instance(ip_address)

        successful_non_bogon_response.json.assert_called_once()
        assert host == filled_host

    for ip_address in bogon_ip_addresses:
        successful_bogon_response.json.reset_mock()
        host = test_traceroute._create_host_instance(ip_address)

        successful_bogon_response.json.assert_called_once()
        assert host == bogon_host

    for ip_address in invalid_ip_addresses:
        failed_response_due_to_ip_address.json.reset_mock()
        host = test_traceroute._create_host_instance(ip_address)

        failed_response_due_to_ip_address.json.assert_called_once()
        assert host == empty_host


def test_fetch_route(mocker, valid_api_token, destination_hosts, expected_and_mock_route_with_hostname_given_destination, expected_and_mock_route_with_ip_given_destination, mock_gethostbyname, mock_create_host_instance):
    logger = mocker.Mock()
    mock_validate_api_token = mocker.Mock()
    mocker.patch("traceroute.traceroute.validate_api_token", mock_validate_api_token)
    mocker.patch("traceroute.traceroute.socket.gethostbyname", mock_gethostbyname)

    mock_traceroute = Traceroute(valid_api_token, logger)
    mock_validate_api_token.assert_called_once_with(valid_api_token)

    # verify exception for invalid hostname is raised
    with pytest.raises(OSError) as exception_information:
        mock_traceroute.fetch_route("definitely-not-in-dict")
    assert str(exception_information.value) == "[Errno -5] No address associated with hostname"

    # a MagicMock object supports conventional operators (division, more specifically)
    mock_ip = mocker.MagicMock()
    mock_udp = mocker.MagicMock()
    mock_sr1 = mocker.Mock()
    mocker.patch("traceroute.traceroute.IP", mock_ip)
    mocker.patch("traceroute.traceroute.UDP", mock_udp)
    mocker.patch("traceroute.traceroute.sr1", mock_sr1)
    mocker.patch("traceroute.traceroute.Traceroute._create_host_instance", mock_create_host_instance)

    # beginning tests on route with hostname-given destination
    expected_route_hostname_given, mock_route_hostname_given = expected_and_mock_route_with_hostname_given_destination
    index_of_destination = len(expected_route_hostname_given) // 2

    # exact match for the number of hops
    maximum_number_of_hops = index_of_destination
    udp_port = 33436
    expected_ip_call_args = [{"dst": destination_hosts[0]["ip"], "ttl": i} for i in range(1, maximum_number_of_hops + 1)]
    expected_udp_call_args = [{"dport": udp_port}] * maximum_number_of_hops
    mock_sr1.side_effect = mock_route_hostname_given
    fetched_route = mock_traceroute.fetch_route(host=destination_hosts[0]["ip"], maximum_number_of_hops=maximum_number_of_hops, udp_port=udp_port)

    assert len(fetched_route) == index_of_destination
    assert all(actual == expected for actual, expected in zip(map(lambda call: call[1], mock_ip.call_args_list), expected_ip_call_args))
    assert all(actual == expected for actual, expected in zip(map(lambda call: call[1], mock_udp.call_args_list), expected_udp_call_args))
    assert all(actual == expected for actual, expected in zip(fetched_route, expected_route_hostname_given[:index_of_destination]))

    # number of hops too low
    mock_ip.reset_mock()
    mock_udp.reset_mock()
    mock_sr1.side_effect = mock_route_hostname_given

    maximum_number_of_hops = index_of_destination // 2
    udp_port = 35697
    expected_ip_call_args = [{"dst": destination_hosts[0]["ip"], "ttl": i} for i in range(1, maximum_number_of_hops + 1)]
    expected_udp_call_args = [{"dport": udp_port}] * maximum_number_of_hops
    fetched_route = mock_traceroute.fetch_route(host=destination_hosts[0]["ip"], maximum_number_of_hops=maximum_number_of_hops, udp_port=udp_port)

    assert len(fetched_route) == maximum_number_of_hops
    assert all(actual == expected for actual, expected in zip(map(lambda call: call[1], mock_ip.call_args_list), expected_ip_call_args))
    assert all(actual == expected for actual, expected in zip(map(lambda call: call[1], mock_udp.call_args_list), expected_udp_call_args))
    assert all(actual == expected for actual, expected in zip(fetched_route, expected_route_hostname_given[:maximum_number_of_hops]))

    # number of hops higher than necessary
    mock_ip.reset_mock()
    mock_udp.reset_mock()
    mock_sr1.side_effect = mock_route_hostname_given

    maximum_number_of_hops = int(index_of_destination * 1.5)
    udp_port = 35656
    expected_ip_call_args = [{"dst": destination_hosts[0]["ip"], "ttl": i} for i in range(1, index_of_destination + 1)]
    expected_udp_call_args = [{"dport": udp_port}] * index_of_destination
    fetched_route = mock_traceroute.fetch_route(host=destination_hosts[0]["ip"], maximum_number_of_hops=maximum_number_of_hops, udp_port=udp_port)

    assert len(fetched_route) == index_of_destination
    assert all(actual == expected for actual, expected in zip(map(lambda call: call[1], mock_ip.call_args_list), expected_ip_call_args))
    assert all(actual == expected for actual, expected in zip(map(lambda call: call[1], mock_udp.call_args_list), expected_udp_call_args))
    assert all(actual == expected for actual, expected in zip(fetched_route, expected_route_hostname_given[:index_of_destination]))

    # number of hops too low, border value
    mock_ip.reset_mock()
    mock_udp.reset_mock()
    mock_sr1.side_effect = mock_route_hostname_given

    maximum_number_of_hops = index_of_destination - 1
    udp_port = 35555
    expected_ip_call_args = [{"dst": destination_hosts[0]["ip"], "ttl": i} for i in range(1, maximum_number_of_hops + 1)]
    expected_udp_call_args = [{"dport": udp_port}] * maximum_number_of_hops
    fetched_route = mock_traceroute.fetch_route(host=destination_hosts[0]["ip"], maximum_number_of_hops=maximum_number_of_hops, udp_port=udp_port)

    assert len(fetched_route) == maximum_number_of_hops
    assert all(actual == expected for actual, expected in zip(map(lambda call: call[1], mock_ip.call_args_list), expected_ip_call_args))
    assert all(actual == expected for actual, expected in zip(map(lambda call: call[1], mock_udp.call_args_list), expected_udp_call_args))
    assert all(actual == expected for actual, expected in zip(fetched_route, expected_route_hostname_given[:maximum_number_of_hops]))

    # number of hops higher than necessary, border value
    mock_ip.reset_mock()
    mock_udp.reset_mock()
    mock_sr1.side_effect = mock_route_hostname_given

    maximum_number_of_hops = index_of_destination + 1
    udp_port = 34456
    expected_ip_call_args = [{"dst": destination_hosts[0]["ip"], "ttl": i} for i in range(1, index_of_destination + 1)]
    expected_udp_call_args = [{"dport": udp_port}] * index_of_destination
    fetched_route = mock_traceroute.fetch_route(host=destination_hosts[0]["ip"], maximum_number_of_hops=maximum_number_of_hops, udp_port=udp_port)

    assert len(fetched_route) == index_of_destination
    assert all(actual == expected for actual, expected in zip(map(lambda call: call[1], mock_ip.call_args_list), expected_ip_call_args))
    assert all(actual == expected for actual, expected in zip(map(lambda call: call[1], mock_udp.call_args_list), expected_udp_call_args))
    assert all(actual == expected for actual, expected in zip(fetched_route, expected_route_hostname_given[:index_of_destination]))

    # beginning test on route with ip-given destination
    expected_route_ip_given, mock_route_ip_given = expected_and_mock_route_with_ip_given_destination
    index_of_destination = len(expected_route_ip_given) // 2
    maximum_number_of_hops = index_of_destination
    udp_port = 34162
    expected_ip_call_args = [{"dst": destination_hosts[1]["ip"], "ttl": i} for i in range(1, maximum_number_of_hops + 1)]
    expected_udp_call_args = [{"dport": udp_port}] * maximum_number_of_hops

    mock_ip.reset_mock()
    mock_udp.reset_mock()
    mock_sr1.side_effect = mock_route_ip_given
    fetched_route = mock_traceroute.fetch_route(host=destination_hosts[1]["ip"], maximum_number_of_hops=maximum_number_of_hops, udp_port=udp_port)

    assert len(fetched_route) == maximum_number_of_hops
    assert all(actual == expected for actual, expected in zip(map(lambda call: call[1], mock_ip.call_args_list), expected_ip_call_args))
    assert all(actual == expected for actual, expected in zip(map(lambda call: call[1], mock_udp.call_args_list), expected_udp_call_args))
    assert all(actual == expected for actual, expected in zip(fetched_route, expected_route_ip_given[:maximum_number_of_hops]))

    # beginning test on route with all-drops
    route_length = 64
    expected_route_all_drops = [Host() for _ in range(route_length)]
    mock_route_all_drops = [None] * route_length

    # max route length
    mock_ip.reset_mock()
    mock_udp.reset_mock()
    mock_sr1.side_effect = mock_route_all_drops

    maximum_number_of_hops = route_length
    udp_port = 33649
    expected_ip_call_args = [{"dst": destination_hosts[0]["ip"], "ttl": i} for i in range(1, maximum_number_of_hops + 1)]
    expected_udp_call_args = [{"dport": udp_port}] * maximum_number_of_hops
    fetched_route = mock_traceroute.fetch_route(host=destination_hosts[0]["ip"], maximum_number_of_hops=maximum_number_of_hops, udp_port=udp_port)

    assert len(fetched_route) == maximum_number_of_hops
    assert all(actual == expected for actual, expected in zip(map(lambda call: call[1], mock_ip.call_args_list), expected_ip_call_args))
    assert all(actual == expected for actual, expected in zip(map(lambda call: call[1], mock_udp.call_args_list), expected_udp_call_args))
    assert all(actual == expected for actual, expected in zip(fetched_route, expected_route_all_drops[:maximum_number_of_hops]))

    # less than max route length
    mock_ip.reset_mock()
    mock_udp.reset_mock()
    mock_sr1.side_effect = mock_route_all_drops

    maximum_number_of_hops = route_length // 2
    udp_port = 33662
    expected_ip_call_args = [{"dst": destination_hosts[1]["ip"], "ttl": i} for i in range(1, maximum_number_of_hops + 1)]
    expected_udp_call_args = [{"dport": udp_port}] * maximum_number_of_hops
    fetched_route = mock_traceroute.fetch_route(host=destination_hosts[1]["ip"], maximum_number_of_hops=maximum_number_of_hops, udp_port=udp_port)

    assert len(fetched_route) == maximum_number_of_hops
    assert all(actual == expected for actual, expected in zip(map(lambda call: call[1], mock_ip.call_args_list), expected_ip_call_args))
    assert all(actual == expected for actual, expected in zip(map(lambda call: call[1], mock_udp.call_args_list), expected_udp_call_args))
    assert all(actual == expected for actual, expected in zip(fetched_route, expected_route_all_drops[:maximum_number_of_hops]))
