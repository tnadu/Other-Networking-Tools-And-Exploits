# The Original Project
## General Description
As a part of the same repository, two unrelated networking tools and two related networking exploits were implemented as an assignment for the Networking course of the University of Bucharest. All of these implementations rely heavily on `scapy`, the packet manipulation package.

## Networking Tools
### Traceroute
While similar to the majority of `traceroute` utilities, this UDP implementation also specifies details such as the country, the region and the city of each host, using the `ipinfo.io` API.
[![asciicast](https://asciinema.org/a/5vBXyG8mZpZTBELXeqRfYp087.svg)](https://asciinema.org/a/5vBXyG8mZpZTBELXeqRfYp087)

### Ad blocking DNS resolver

## Networking Exploits
The desired architecture on which the exploits are designed to run is described below from a networking perspective.

```
            MIDDLE------------\
        subnet2: x.x.x.3       \
        MAC: xx:xx:xx:xx:xx:03  \
               forwarding        \ 
              /                   \
             /                     \
Poison ARP x.x.x.1 is-at          Poison ARP x.x.x.2 is-at
           xx:xx:xx:xx:xx:03         |       xx:xx:xx:xx:xx:03
           /                         |
          /                          |
         /                           |
        /                            |
    SERVER <---------------------> ROUTER <---------------------> CLIENT
subnet2: x.x.x.2                     |                          subnet1: y.y.y.2
MAC: xx:xx:xx:xx:xx:02               |                          MAC: yy:yy:yy:yy:yy:02
                           subnet1:  y.y.y.1
                           MAC eth0: yy:yy:yy:yy:yy:01
                           subnet2:  x.x.x.1
                           MAC eth1: xx:xx:xx:xx:xx:01
                           subnet2 <------> subnet1
                                  forwarding
```

### ARP Spoofing

### TCP Hijacking 

# Testing The Original Project
## General Description
The main reason we chose `pytest` over plain `unittest` is the fact that we were simply more familiar with it. At the same time, `pytest` offers the possibility of writing more concise, flexible, and readable tests compared to unittest. The simple syntax and powerful features like fixtures, parameterization, and plugins were also big advantages when choosing whether to switch or not. Failure reports are more detailed and clear, and the automatic discovery of tests means reduced setup overhead.

In terms of code coverage, `coverage.py` is the only actively-maintained tool, so there wasn't much of a choice. For mutation testing, there's either `mutmut` or `Cosmic Ray`, with the former being much more straight-forward and easier to set up and run.

[!IMPORTANT]
Add coverage results, including an asciinema gif, when the testing is completed

## Networking Tools
### Traceroute
After refactoring the original script, from a functional centered approach to a set of more maintainable classes with methods better aligned with separation of concern, the units worth testing became quite clear. The `Host` class consists of mostly boilerplate code, and is only responsible with storing fields under single objects, which is also why it is later excluded from both code coverage reports, and from mutations.

#### API token validation function - `validate_api_token()`:
- given that the function depends on the `ip-info.io` API, the request is mocked using a function which is designed to replicate said API, in terms of input validation (API token and IP address)
- the mock function, and the mock responses are stored within pytest fixtures
- equivalence classes:
  - invalid API token: `ValueError` Exception
  - valid API token: success, no effect
  - empty API token: success, no effect

#### Host instance creation method - `Traceroute._create_host_instance()`:
- the request to the `ip-info.io` API is mocked using the same function which is described in the previous section
- equivalence classes:
  - invalid IP address: Host instance with all its values set to `None`
    - values out of the valid range 0-255
    - missing byte
    - extra byte
    - non-numerical strings in the place of an individual byte
    - bytes separated by `,` instead of `.`
    - leading 0s (`01` instead of `1`)
  - valid IP address: Host instance with all its values set to values other than `None`
  - bogon IP address (private, reserved, and non-routable): Host instance with all its values set to `None`, except the IP address

#### Route fetching method - `Traceroute.fetch_route()`:
- due to the fact that this method depends on the previously tested units, I decided to mock them:
  - `validate_api_token()`: always returns `None`, because only the valid API token is passed every time; the fact that it is called once is verified
  - logger: does nothing, as logging isn't the purpose of the tests
  - `socket.gethostbyname()`: mimics the response of the stub DNS resolver, returning the associated IP address of the destination host fixtures, or raising an `OSError` Exception
  - `scapy.all.IP`: might involve network calls; the right order of instantiation is verified, as well as the embedding of the associated UDP packet
  - `scapy.all.UDP`: might involve network calls
  - `scapy.all.sr1()`: will return one mock response in the route at a time
  - `Traceroute._create_host_instance()`: returns a Host object, based on the given IP address
- there is little certainty behind the lack of a response from a host. in terms of causes, it might be that either the timeout was too restrictive, and the request took longer to process, or that the host in question is configured so that ICMP `time-exceeded` packets are dropped. even though not knowing the IP address of a given host can be annoying, the effects of a lack of a response can be much more serious when that host is the destination itself. when the destination fails to respond, the halting condition cannot be satisfied, and the program never stops, as each increase in the TTL of the IP packets is completely futile, since the packets themselves reach the destination successfully. the main problem is that there is no way of confidently asserting whether the destination has indeed been reached, or if there are still hosts left on the path to the destination, while the ones reached so far simply didn't respond. it is, then, far less important if the hosts on the route to the destination choose to respond or not
- equivalence classes:
  - the destination host:
    - responds with ICMP `destination unreachable`
    - doesn't respond with ICMP `destination unreachable`
  - the maximum number of hops:
    - too short
    - exact match
    - too long
- boundary values:
  - the maximum number of hops:
    - 1 less than necessary to reach the destination
    - 1 more than necessary to reach the destination
- taking everything into account, two routes were mocked:
  - no host on the route responds within the given timeout, including the destination
  - some hosts on the route respond, some do not, and the destination responds

#### Mutation testing
In order to better isolate the code sequences which were tested, others had to be exempt from mutations: the `Host` class, logging statements, and the CLI. Before the extra checks:

[![asciicast](https://asciinema.org/a/8KHTKneQwxProEU1CVqkS5ZGe.svg)](https://asciinema.org/a/8KHTKneQwxProEU1CVqkS5ZGe)
As shown above, **34 mutants** resulted from mutating each of the remaining statements, of which **6 survived** initially. Four of them were 'benign', in the sense that only default values of method parameters were modified, while the other two required additional checks within the tests. One of them should have been killed, but wasn't due to a bug, and the other involved changing the operator `/` operator to `*` when embedding the UDP packet in the IP one, which was not accounted for. After the modifications, the two mutants got killed:

[![asciicast](https://asciinema.org/a/gIhmqMG0YtERDezkHs0EbFXdB.svg)](https://asciinema.org/a/gIhmqMG0YtERDezkHs0EbFXdB)

### Ad blocking DNS resolver

## Networking Exploits
### ARP Spoofing

### TCP Hijacking


# Installation
### Prerequisites
Python 3.11 should be installed locally. There is no guarantee of compatibility with any other versions, though everything might work just as intended. The following guide describes a Linux installation, but fairly similar steps should work on other operating systems. Also, a virtual environment will be used to install the necessary packages, but you may try to install everything globally at your own risk. We used `venv` out of convenience, but any other virtual environment tool will work.

### Recommended steps
1. Clone this repository
```bash
git clone https://github.com/tnadu/Other-Networking-Tools-And-Exploits.git && cd Other-Networking-Tools-And-Exploits
```

2. Create a virtual environment
```bash
python3 -m venv .venv
```

3. Activate the virtual environment
```bash
source .venv/bin/activate
```

4. Install the dependencies
```bash
pip install -r requirements.txt
```

# Usage
## Tool usage
Each tool has a `--help` flag with detailed explanations about the intended usage, and the necessary CLI flags and parameters.

## Running the tests
If code coverage reports aren't of concern, then simply run `pytest` from the root of the repository. For code coverage, run `coverage run --branch -m pytest` to run the tests, and `coverage report` for a short description of the tests which have just been executed. When a more detailed description is required, an interactive HTML page can be generated by running `coverage html`, and accessed at `htmlcov/index.html`.

In order to run a suite of mutation tests, simply execute `mutmut run --paths-to-mutate src/` from the root of the repository.