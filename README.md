# The Original Project
## General Description
As a part of the same repository, two networking tools were implemented as an assignment for the Networking course of the University of Bucharest. Both of these implementations rely heavily on `scapy`, the packet manipulation package.

## Networking Tools
### Traceroute
While similar to the majority of `traceroute` utilities, this UDP implementation also specifies details such as the country, the region and the city of each host, using the `ipinfo.io` API.
[![asciicast](https://asciinema.org/a/5vBXyG8mZpZTBELXeqRfYp087.svg)](https://asciinema.org/a/5vBXyG8mZpZTBELXeqRfYp087)

### Ad blocking DNS resolver
The script operates by intercepting DNS queries, where it promptly examines whether the requested domain resides on a list of ad servers or undesired domains. If the domain is found on the list, it returns a DNS response with a block IP address. Otherwise, it forwards the DNS query to root servers, TLD servers, and authoritative servers to fetch the appropriate DNS response.

# Testing The Original Project
## General Description
The main reason we chose `pytest` over plain `unittest` is the fact that we were simply more familiar with it. At the same time, `pytest` offers the possibility of writing more concise, flexible, and readable tests compared to unittest. The simple syntax and powerful features like fixtures, parameterization, and plugins were also big advantages when choosing whether to switch or not. Failure reports are more detailed and clear, and the automatic discovery of tests means reduced setup overhead.

In terms of code coverage, `coverage.py` is the only actively-maintained tool, so there wasn't much of a choice. For mutation testing, there's either `mutmut` or `Cosmic Ray`, with the former being much more straight-forward and easier to set up and run.

The following recording showcases the execution of the test suite, and the resulting code coverage, both at the statement, and at the branch level.
[![asciicast](https://asciinema.org/a/MCKMy12sI3wSbsbkJ85xzCsAt.svg)](https://asciinema.org/a/MCKMy12sI3wSbsbkJ85xzCsAt)

## Networking Tools
### Traceroute
After refactoring the original script, from a functional centered approach to a set of more maintainable classes with methods better aligned with separation of concern, the units worth testing became quite clear. The `Host` class consists of mostly boilerplate code, and is only responsible with storing fields under single objects, which is also why it is later excluded from both code coverage reports, and from mutations.

#### API token validation function - `validate_api_token()`:
- given that the function depends on the `ip-info.io` API, the request is mocked using a function which is designed to replicate said API, in terms of input validation (API token and IP address)
- the mock function, and the mock responses are stored within pytest fixtures
- equivalence classes:
  - invalid API token: `ValueError` Exception
  - valid API token: success, no effect
  - empty API token: success, no effect

#### Host instance creation method - `Traceroute._create_host_instance()`:
- the request to the `ip-info.io` API is mocked using the same function which is described in the previous section
- equivalence classes:
  - invalid IP address: Host instance with all its values set to `None`
    - values out of the valid range 0-255
    - missing byte
    - extra byte
    - non-numerical strings in the place of an individual byte
    - bytes separated by `,` instead of `.`
    - leading 0s (`01` instead of `1`)
  - valid IP address: Host instance with all its values set to values other than `None`
  - bogon IP address (private, reserved, and non-routable): Host instance with all its values set to `None`, except the IP address

#### Route fetching method - `Traceroute.fetch_route()`:
- due to the fact that this method depends on the previously tested units, I decided to mock them:
  - `validate_api_token()`: always returns `None`, because only the valid API token is passed every time; the fact that it is called once is verified
  - logger: does nothing, as logging isn't the purpose of the tests
  - `socket.gethostbyname()`: mimics the response of the stub DNS resolver, returning the associated IP address of the destination host fixtures, or raising an `OSError` Exception
  - `scapy.all.IP`: might involve network calls; the right order of instantiation is verified, as well as the embedding of the associated UDP packet
  - `scapy.all.UDP`: might involve network calls
  - `scapy.all.sr1()`: will return one mock response in the route at a time
  - `Traceroute._create_host_instance()`: returns a Host object, based on the given IP address
- there is little certainty behind the lack of a response from a host. in terms of causes, it might be that either the timeout was too restrictive, and the request took longer to process, or that the host in question is configured so that ICMP `time-exceeded` packets are dropped. even though not knowing the IP address of a given host can be annoying, the effects of a lack of a response can be much more serious when that host is the destination itself. when the destination fails to respond, the halting condition cannot be satisfied, and the program never stops, as each increase in the TTL of the IP packets is completely futile, since the packets themselves reach the destination successfully. the main problem is that there is no way of confidently asserting whether the destination has indeed been reached, or if there are still hosts left on the path to the destination, while the ones reached so far simply didn't respond. it is, then, far less important if the hosts on the route to the destination choose to respond or not
- equivalence classes:
  - the destination host:
    - responds with ICMP `destination unreachable`
    - doesn't respond with ICMP `destination unreachable`
  - the maximum number of hops:
    - too short
    - exact match
    - too long
- boundary values:
  - the maximum number of hops:
    - 1 less than necessary to reach the destination
    - 1 more than necessary to reach the destination
- taking everything into account, two routes were mocked:
  - no host on the route responds within the given timeout, including the destination
  - some hosts on the route respond, some do not, and the destination responds

#### Mutation testing
In order to better isolate the code sequences which were tested, others had to be exempt from mutations: the `Host` class, logging statements, and the CLI. Before the extra checks:

[![asciicast](https://asciinema.org/a/8KHTKneQwxProEU1CVqkS5ZGe.svg)](https://asciinema.org/a/8KHTKneQwxProEU1CVqkS5ZGe)
As shown above, **34 mutants** resulted from mutating each of the remaining statements, of which **6 survived** initially. Four of them were 'benign', in the sense that only default values of method parameters were modified, while the other two required additional checks within the tests. One of them should have been killed, but wasn't due to a bug, and the other involved changing the operator `/` operator to `*` when embedding the UDP packet in the IP one, which was not accounted for. After the modifications, the two mutants got killed:

[![asciicast](https://asciinema.org/a/gIhmqMG0YtERDezkHs0EbFXdB.svg)](https://asciinema.org/a/gIhmqMG0YtERDezkHs0EbFXdB)

### Ad blocking DNS resolver
#### DNS resolver - `send_receive()`
- mocked because it relies on external requests
- equivalence classes: 
  - `None`
  - `DNS(ar=DNSRR(rdata=response_address, type=1)/DNSRR(rdata=response_address, type=2), an=None)`
  - `DNS(rcode=2)`
  - `DNS(ns=DNSRR(rdata=response_address, type=rr_type), an=None)`
  - `DNS(an=DNSRR(rdata=response_address, type=5))`
  - `DNS(an=DNSRR(rdata=response_address, type=1))`

#### DNS resolver - `google_request()`
- is a particular case of `send_receive` where the proxy address is the Google DNS server
- mocked because it relies on external requests
- equivalence classes: 
  - `None`
  - `DNS(ar=DNSRR(rdata=response_address, type=1)/DNSRR(rdata=response_address, type=2), an=None)`
  - `DNS(rcode=2)`
  - `DNS(ns=DNSRR(rdata=response_address, type=rr_type), an=None)`
  - `DNS(an=DNSRR(rdata=response_address, type=5))`
  - `DNS(an=DNSRR(rdata=response_address, type=1))`
  - response_address can be `valid` or `invalid`, but when `an` section contain a result, it can only be `valid`

#### Error response retrieval - `send_response_server_error()`
- no external dependencies are mocked in this method.
- equivalence classes:
  - query type:
    - `1 = A, 2 = NS, 5 = CNAME, 15 = MX, 28 = AAAA, 99 = UNKNOWN`
  - requested domain:
    - `valid` / `invalid`
- boundary values:
  - requested domain:
    - `valid` / `invalid`
		
#### Random response fetching - `pick_random_root_server()`
- mocked because it relies on "random" method which is used to generate random responses
- equivalence classes: 
  - valid index : `[0, 12]`
    - invalid index: `.. )0 12(...`
- boundary values:
  - `1, 0, 12, 13`

#### Random response return - `pick_random_response()`
- mocked because it relies on "randrange" method which is used to generate random responses
- equivalence classes: 
  - valid index : `[0, len(response.answerList) - 1]`
  - invalid index: `.. )0 len(response.answerList) -1 (...`
- boundary values:
  - `1, 0, len(response.answerList) - 1, len(response.answerList)`

#### Root level response fetching - `send_request_root_server()`
- mocked using all the previous methods described above
- equivalence classes:
  - `DNS_error_response = DNS(id = DNS_packet[DNS].id,qr = 1,aa = 0,rcode = 2,qd = DNS_packet.qd)`
  - `None`
  - `DNS(ar=DNSRR(rdata=response_address, type=1)/DNSRR(rdata=response_address, type=2), an=None)`
  - `DNS(rcode=2)`
  - `DNS(ns=DNSRR(rdata=response_address, type=rr_type), an=None)`
  - `DNS(an=DNSRR(rdata=response_address, type=1))`
  - `DNS(id=0, qr=1, aa=0, rcode=0, qd=DNSQR(qname=requested_domain, qtype=28, qclass=1), an=DNSRR(rrname=requested_domain, ttl=500, type=28, rclass="IN", rdata="::"))`
  - `DNS(id=0, qr=1, aa=0, rcode=0, qd=DNSQR(qname=requested_domain, qtype=1, qclass=1), an=DNSRR(rrname=requested_domain, ttl=500, type=1, rclass="IN", rdata="0.0.0.0"))`
- boundary values:
  - response with `rcode = 0`, response with `rcode != 0`

#### TLD level response fetching - `send_request_tld_server()`
- mocked using all the previous methods described above
- equivalence classes:
  - `DNS_error_response = DNS(id = DNS_packet[DNS].id,qr = 1,aa = 0,rcode = 2,qd = DNS_packet.qd)`
  - `None`
  - `DNS(ar=DNSRR(rdata=response_address, type=1)/DNSRR(rdata=response_address, type=2), an=None)`
  - `DNS(rcode=2)`
  - `DNS(ns=DNSRR(rdata=response_address, type=rr_type), an=None)`
  - `DNS(an=DNSRR(rdata=response_address, type=5))`
  - `DNS(an=DNSRR(rdata=response_address, type=1))`
  - `DNS(id=0, qr=1, aa=0, rcode=0, qd=DNSQR(qname=requested_domain, qtype=28, qclass=1), an=DNSRR(rrname=requested_domain, ttl=500, type=28, rclass="IN", rdata="::"))`
  - `DNS(id=0, qr=1, aa=0, rcode=0, qd=DNSQR(qname=requested_domain, qtype=1, qclass=1), an=DNSRR(rrname=requested_domain, ttl=500, type=1, rclass="IN", rdata="0.0.0.0"))`
- boundary values:
  - response with `rcode = 0`, response with `rcode != 0`

#### Authoritative level response fetching - `send_request_authoritative_server()`
- mocked using all the previous methods described above
- equivalence classes:
  - `DNS_error_response = DNS(id = DNS_packet[DNS].id,qr = 1,aa = 0,rcode = 2,qd = DNS_packet.qd)`
  - `None`
  - `DNS(ar=DNSRR(rdata=response_address, type=1)/DNSRR(rdata=response_address, type=2), an=None)`
  - `DNS(rcode=2)`
  - `DNS(ns=DNSRR(rdata=response_address, type=rr_type), an=None)`
  - `DNS(an=DNSRR(rdata=response_address, type=5))`
  - `DNS(an=DNSRR(rdata=response_address, type=1))`
  - `DNS(id=0, qr=1, aa=0, rcode=0, qd=DNSQR(qname=requested_domain, qtype=28, qclass=1), an=DNSRR(rrname=requested_domain, ttl=500, type=28, rclass="IN", rdata="::"))`
  - `DNS(id=0, qr=1, aa=0, rcode=0, qd=DNSQR(qname=requested_domain, qtype=1, qclass=1), an=DNSRR(rrname=requested_domain, ttl=500, type=1, rclass="IN", rdata="0.0.0.0"))`
- boundary values:
  - response with `rcode = 0`, response with `rcode != 0`

#### Response filtering - `filter_dns_answer()`
- no external dependencies are mocked in this method.
- equivalence classes:
  - all from `send_request_root_server`, with `response[DNS].aa = 0`

#### DNS resolvers - `single_record_lookup() & multiple_records_lookup()`
- mocked using all the previous methods described above
- equivalence classes:
   - `DNS_error_response = DNS(id = DNS_packet[DNS].id,qr = 1,aa = 0,rcode = 2,qd = DNS_packet.qd)`
   - `None`
   - `DNS(ar=DNSRR(rdata=response_address, type=1)/DNSRR(rdata=response_address, type=2), an=None)`
   - `DNS(rcode=2)`
   - `DNS(ns=DNSRR(rdata=response_address, type=rr_type), an=None)`
   - `DNS(an=DNSRR(rdata=response_address, type=5))`
   - `DNS(an=DNSRR(rdata=response_address, type=1))`
   - `DNS(id=0, qr=1, aa=0, rcode=0, qd=DNSQR(qname=requested_domain, qtype=28, qclass=1), an=DNSRR(rrname=requested_domain, ttl=500, type=28, rclass="IN", rdata="::"))`
   - `DNS(id=0, qr=1, aa=0, rcode=0, qd=DNSQR(qname=requested_domain, qtype=1, qclass=1), an=DNSRR(rrname=requested_domain, ttl=500, type=1, rclass="IN", rdata="0.0.0.0"))`
- boundary values:
  - response with `rcode = 0`, response with `rcode != 0`

#### Query type interpreter - `interpret_DNS_qtype()`
- no external dependencies are mocked in this method.
- equivalence classes: 
  - `1 = A, 2 = NS, 5 = CNAME, 15 = MX, 28 = AAAA, 99 = UNKNOWN`

#### Blocker response fetching - `get_ad_blocker_response()`
- no external dependencies are mocked in this method.
equivalence classes: 
  - `DNS_response = DNS(id=DNS_packet[DNS].id, qr=1, aa=0, rcode=0, qd=DNS_packet.qd, an=DNSRR(rrname=DNS_packet[DNS].qd.qname, ttl=500, type=DNS_packet[DNS].qd.qtype, rclass="IN", rdata=rdata_address))`
  - where `rdata_address` can be: `0.0.0.0` or `::`

#### Response display methods - `display_DNS_query() & display_DNS_response()`
- no external dependencies are mocked in this method, used only for logging

#### Mutation testing
Before starting the mutation process, some of the functionalities have been protected from it, such as: *google_request*, *send_recive*, *send_response_server_error*, etc. Those were marked to not be mutated. Before the extra testing, the mutation looked as:

[![asciicast](https://asciinema.org/a/n2IhoKCNZIiI1u9ARgS3BcUbG.svg)](https://asciinema.org/a/n2IhoKCNZIiI1u9ARgS3BcUbG)
It can be seen in the video above, **83 mutants** were created, from which **9 survived**. To kill a part of them, additional test were added:

- *test_send_request_tld_server*: 
  - `(create_dns_answer_packet(valid_query_domain),`
  - `DNS(ar=DNSRR(rdata=response_ip_address, type=1), arcount=1, ns=DNSRR(rdata=response_ip_address, type=6), an=None),`
  - `[0],`
  - `None,`
  - `None,`
  - `DNS(ar=DNSRR(rdata=response_ip_address, type=1), arcount=1, ns=DNSRR(rdata=response_ip_address, type=6), an=None))`
  - this extra test targeted the case when only one *ar* response was returned from the TLD server, and one *ns* response of *SOA* type which should have been returned directly 
- *test_multiple_records_lookup*: 
  - `(DNS(id=1, qd=DNSQR(qname=valid_query_domain, qtype=2, qclass=1), rd=1),`
  - `DNS(id=1, an=DNSRR(rdata=invalid_query_domain, type=1), rcode=5),`
  - `DNS(id=1, aa=0, qd=DNSQR(qname=valid_query_domain, qtype=2, qclass=1), an=DNSRR(rdata=invalid_query_domain, type=1), rcode=5))`
  - this extra test targeted the case when the DNS response contained an error, which should return the DNS packet containing the initial query, plus the error *rcode* generated

After extra tests were added:

[![asciicast](https://asciinema.org/a/yFM2V1181zzz1ZJSLjQTj4wZl.svg)](https://asciinema.org/a/yFM2V1181zzz1ZJSLjQTj4wZl)

# Installation
### Prerequisites
Python 3.11 should be installed locally. There is no guarantee of compatibility with any other versions, though everything might work just as intended. The following guide describes a Linux installation, but fairly similar steps should work on other operating systems. Also, a virtual environment will be used to install the necessary packages, but you may try to install everything globally at your own risk. We used `venv` out of convenience, but any other virtual environment tool will work.

### Recommended steps
1. Clone this repository
```bash
git clone https://github.com/tnadu/Other-Networking-Tools-And-Exploits.git && cd Other-Networking-Tools-And-Exploits
```

2. Create a virtual environment
```bash
python3 -m venv .venv
```

3. Activate the virtual environment
```bash
source .venv/bin/activate
```

4. Install the dependencies
```bash
pip install -r requirements.txt
```

# Usage
## Tool usage
Each tool has a `--help` flag with detailed explanations about the intended usage, and the necessary CLI flags and parameters.

## Running the tests
If code coverage reports aren't of concern, then simply run `pytest` from the root of the repository. For code coverage, run `coverage run --branch -m pytest` to run the tests, and `coverage report` for a short description of the tests which have just been executed. When a more detailed description is required, an interactive HTML page can be generated by running `coverage html`, and accessed at `htmlcov/index.html`.

In order to run a suite of mutation tests, simply execute `mutmut run --paths-to-mutate src/` from the root of the repository.
